{
	function parse_op_repetition(name, head, tail) {
        if (tail.length === 0) {
            return head;
        }
        let rv = null;
        tail.map(function (item) {
            if (rv !== null && item.op === rv.op) {
                rv.vals.push(item.val);
            } else {
                if (rv === null) {
                    rv = head;
                }
                rv = {
                    type: name,
                    op: item.op,
                    vals: [rv, item.val]
                };
            }
        });
        return rv;
    }
    
    function parse_mapping(head, tail) {
        let rv = {};
        rv[head.key] = head.val;
        tail.map(function (item) {
            rv[item.key] = item.val;
        });
        return rv;
    }
}

// QUERY
Query
  = _ select:SelectStatement 
  blk from:FromStatement 
  unnest:(blk UnNestStatement)* 
  let_:(blk LetStatement)?
  where:(blk WhereStatement)? 
  pre_group_skip:(blk SkipStatement)? 
  pre_group_limit:(blk LimitStatement)?
  group_by:(blk GroupByStatement)? 
  letting:(blk LettingStatement)?
  having:(blk HavingStatement)? 
  order_by:(blk OrderByStatement)? 
  final_skip:(blk SkipStatement)? 
  final_limit:(blk LimitStatement)? _ {
      return {
          type: "query",
          select: select,
          from: from,
          unnests: unnest.map(function (item) { return item[1]; }),
          let: let_ ? let_[1] : null,
          where: where ? where[1] : null,
          pre_group_skip: pre_group_skip ? pre_group_skip[1] : null,
          pre_group_limit: pre_group_limit ? pre_group_limit[1] : null,
          group_by: group_by ? group_by[1] : null,
          letting: letting ? letting[1] : null,
          having: having ? having[1] : null,
          order_by: order_by ? order_by[1] : null,
          final_skip: final_skip ? final_skip[1] : null,
          final_limit: final_limit ? final_limit[1] : null
      };
  }
  /
  "(" _ query:Query _ ")" {
      return query; 
  }
  
// STATEMENTS
SelectStatement
  = "SELECT"i blk map:(SelectMapping / SimplifiedSelectMapping) {
      return {
          type: "select_stat",
          map: map
      };
  }

SimplifiedSelectMapping
  = head:SimplifiedSelectMappingKeyVal tail:(_ "," _ kv:SimplifiedSelectMappingKeyVal { return kv; })* {
     return {
         type: "simplified_select_mapping",
         map: [head].concat(tail)
     };
  }

SimplifiedSelectMappingKeyVal
  = expr:(Expression / ExprReducer) alias:(blk "AS"i blk KeyName)? {
      return {
          expr: expr,
          alias: alias
      };
  }

SelectMapping 
  = "{" _ head:SelectMappingKeyVal tail:(_ "," _ kv:SelectMappingKeyVal { return kv; })* _ "}" { 
        return {
        	type: "select_mapping",
        	map: parse_mapping(head, tail)
        };
    }
    
SelectMappingKeyVal
  = key:KeyName _ ":" _ val:(LimitedQuery / SelectMapping / ExprReducer / Expression) {
      return {
          key: key,
          val: val
      };
  }

FromStatement
  = "FROM"i blk from:(Path / Query) alias:(blk "AS"i blk KeyName)? {
      return {
          type: "from_stat",
          alias: alias ? alias[3] : null,
          from: from
      };
  }

UnNestStatement
  = "UNNEST"i blk path:Path {
      return {
          type: "unnest_stat",
          path: path
      };
  }

LetStatement
  = "LET"i blk head:LetKeyVal tail:(_ "," _ kv:LetKeyVal { return kv; })* {
      return {
          type: "let_stat",
          kvs: [head].concat(tail)
      };
  }

LetKeyVal
  = key:KeyName _ "=" _ expr:Expression {
      return {
          key: key,
          expr: expr
      };
  }

WhereStatement
  = "WHERE"i blk cond:Condition {
      return {
          type: "where_stat",
          cond: cond
      };
  }

GroupByStatement
  = "GROUP"i blk "BY"i blk head:Expression tail:(_ "," _ expr:Expression { return expr; })* {
      return {
          type: "group_by_stat",
          exprs: [head].concat(tail)
      };
  }

LettingStatement
  = "LETTING"i blk head:LetKeyVal tail:(_ "," _ kv:LetKeyVal { return kv; })* {
      return {
          type: "letting_stat",
          kvs: [head].concat(tail)
      };
  }

HavingStatement
  = "HAVING"i blk cond:Condition {
      return {
          type: "having_stat",
          cond: cond
      };
  }

OrderByStatement
  = "ORDER"i blk "BY"i blk head:OrderByStatementItem tail:(_ "," _ item:OrderByStatementItem { return item; })* {
      return {
          type: "order_by_stat",
          orders: [head].concat(tail)
      };
  }

OrderByStatementItem
  = expr:Expression op:(blk ("ASC"i / "DESC"i))? {
      return {
          expr: expr,
          order: op ? op[1].toUpperCase() : "ASC"
      };
  }

SkipStatement
  = "SKIP"i blk val:Integer {
      return {
          type: "skip_stat",
          value: val
      };
  }
  
LimitStatement
  = "LIMIT"i blk val:Integer {
      return {
          type: "limit_stat",
          value: val
      };
  }

// LIMITED QUERY
LimitedQuery 
  =  _ select:LimitedSelectStatement 
  blk from:LimitedFromStatement 
  let_:(blk LetStatement)?
  where:(blk WhereStatement)? 
  skip:(blk SkipStatement)? 
  limit:(blk LimitStatement)?
  concat:(blk ConcatStatement)? _ {
      return {
          type: "limited_query",
          select: select,
          from: from,
          let: let_ ? let_ : null,
          where: where ? where[1] : null,
          skip: skip ? skip[1] : null,
          limit: limit ? limit[1] : null,
          concat: concat ? concat[1] : null
      };
  }
  /
  "(" _ query:LimitedQuery _ ")" {
      return query; 
  }

// STATEMENTS
LimitedSelectStatement
  = "SELECT"i blk map:(LimitedSelectMapping / LimitedSimplifiedSelectMapping) {
      return {
          type: "limited_select_stat",
          map: map
      };
  }

LimitedSimplifiedSelectMapping
  = head:LimitedSimplifiedSelectMappingKeyVal tail:(_ "," _ kv:LimitedSimplifiedSelectMappingKeyVal { return kv; })* {
     return {
         type: "limited_simplified_select_mapping",
         map: [head].concat(tail)
     };
  }

LimitedSimplifiedSelectMappingKeyVal
  = expr:Expression alias:(blk "AS"i blk KeyName)? {
      return {
          expr: expr,
          alias: alias
      };
  }

LimitedSelectMapping 
  = "{" _ head:LimitedSelectMappingKeyVal tail:(_ "," _ kv:LimitedSelectMappingKeyVal { return kv; })* _ "}" { 
        return {
        	type: "limited_select_mapping",
        	map: parse_mapping(head, tail)
        };
    }
    
LimitedSelectMappingKeyVal
  = key:KeyName _ ":" _ val:(LimitedQuery / SelectMapping / Expression) {
      return {
          key: key,
          val: val
      };
  }

LimitedFromStatement
  = "FROM"i blk from:(Path / LimitedQuery) alias:(blk "AS"i blk KeyName)? {
      return {
          type: "limited_from_stat",
          alias: alias ? alias[3] : null,
          from: from
      };
  }

ConcatStatement
  = op:("UNION"i / "INTERSECT"i / "EXCEPT"i) blk query:LimitedQuery {
     return {
         type: "concat_stat",
         op: op[1].toUpperCase(),
         query: query
     };
  }

// REDUCERS
Reducer
  = ExprReducer 
  / "(" _ red:Reducer _ ")" {
      return red;
  }

ExprReducer
  = op:("SUM"i / "AVG"i / "COUNT"i / "MAX"i / "MIN"i) _ "(" _ expr:Expression _ ")" {
      return {
          type: "expr_red",
          op: op.toUpperCase(),
          expr: expr
      };
  }

// CONDITIONS
Condition
  = OrCondition

OrCondition
  = head:AndCondition tail:(blk "OR"i blk cond:AndCondition { return { op: "OR", val: cond}; })* { 
      return parse_op_repetition("nary_cond_cond", head, tail);
  }

AndCondition
  = head:BaseCondition tail:(blk "AND"i blk cond:BaseCondition { return { op: "AND", val: cond}; })* { 
      return parse_op_repetition("nary_cond_cond", head, tail);
  }

BaseCondition
  = IsNullCondition 
  / BinaryExprCondition 
  / EachCondCondition 
  / ListCondition 
  / LikeCondition 
  / NotCondition 
  / "(" _ cond:Condition _ ")" { 
          return cond;
    }

NotCondition
  = "NOT"i blk cond:BaseCondition { 
          return {
            type: "not_cond",
            cond: cond
        };
    }

EachCondCondition
  = op:("ANY"i / "ALL"i) blk path:Path blk "MATCH"i blk cond:BaseCondition { 
          return {
            type: "each_cond_cond",
            path: path,
            op: op.toUpperCase(),
            cond: cond
        };
    }

ListCondition
  = path:Path blk op:( "IN"i / "NIN"i ) blk "(" _ head:Value tail:(_ "," _ val:Value { return val; })* _ ")" { 
          return {
            type: "list_cond",
            path: path,
            op: op.toUpperCase(),
            values: [head].concat(tail)
        };
    }

LikeCondition
  = path:Path blk "LIKE"i blk regex:String { 
        return {
            type: "like_cond",
            path: path,
            regex: regex
        };
    }
  
IsNullCondition
  = path:Path blk "IS"i blk "NULL"i { 
          return {
            type: "is_null_cond",
            path: path
        };
    }

BinaryExprCondition
  = lhe:Expression _ op:( "<=" / "<" / ">=" / ">" / "!=" / "=" ) _ rhe:Expression { 
          return {
            type: "binary_expr_cond",
            lhe: lhe,
            op: op,
            rhe: rhe
        };
    }

// EXPRESSIONS
Expression
  = AddExpression

AddExpression
  = head:MulExpression tail:(_ op:( "+" / "-" ) _ expr:MulExpression { return { op:op, val: expr}; })* { 
      return parse_op_repetition("nary_expr_expr", head, tail);
  }
  
MulExpression
  = head:BaseExpression tail:(_ op:( "*" / "/" ) _ expr:BaseExpression { return { op:op, val: expr}; })* { 
      return parse_op_repetition("nary_expr_expr", head, tail);
  }
      
BaseExpression
  = ReducedExpression
  / Value
  / Path 
  / "("_ expr:Expression _ ")" {
      return expr;
  }

ReducedExpression
  = "ARRAY_" op:("SUM"i / "AVG"i / "MIN"i / "MAX"i / "COUNT"i) _ "(" _ path:Path query:(_ "," _ LimitedQuery)? _ ")" {
      return {
          type: "reduced_expr",
          path: path,
          query: query ? query[3] : null
      };
  }

Path
  = head:IndexedKeyName tail:("." val:IndexedKeyName { return val; })* { 
      return {
          type: "path",
          value: [head].concat(tail)
      };
  }

IndexedKeyName
  = key:KeyName idx:(ArrayIndex)? {
      return {
          key: key,
          index: idx 
      };
  }

ArrayIndex
  = "[" _ index:([0-9]+) _ "]" {
      return parseInt(index.join(""), 10);
  }

Value
  = String 
  / Boolean 
  / Number 
  / Date 
  / Timestamp

Timestamp
  = "TIMESTAMP"i blk "\"" year:(digit digit digit digit) "-" month:(digit digit) "-" day:(digit digit) " " hour:(digit digit) ":" minutes:(digit digit) ":" seconds:(digit digit) "\"" { 
        return {
            type: "timestamp",
            value: new Date(
                parseInt(year.join(""), 10), 
                parseInt(month.join(""), 10),
                parseInt(day.join(""), 10),
                parseInt(hour.join(""), 10),
                parseInt(minutes.join(""), 10),
                parseInt(seconds.join(""), 10)
            )
        };
    }

Date
  = "DATE"i blk "\"" year:(digit digit digit digit) "-" month:(digit digit) "-" day:(digit digit) "\"" { 
        return {
            type: "date",
            value: new Date(
                parseInt(year.join(""), 10), 
                parseInt(month.join(""), 10),
                parseInt(day.join(""), 10)
            )
        };
    }

digit
  = [0-9]

Boolean
  = ("TRUE"i / "FALSE"i) { 
        return {
            type: "value",
            value: text().toUpperCase() === "TRUE" 
        };
    }

String
  = "\"" val:[^"]* "\"" { 
          return {
            type: "string",
            value: val.join("")
        };
    }

Number
  = Integer 
  / Float

Float
  = ("-"/"+")?[0-9]+("."[0-9]+)? { 
          return {
            type: "float",
            value: parseFloat(text())
        };
    }

Integer
  = ("-"/"+")?[0-9]+ { 
          return {
            type: "integer",
            value: parseInt(text(), 10)
        };
    }

KeyName
  = [a-zA-Z0-9_-]+ {
        return text();
  }
 
blk
    = [ \t\n\r]+
_
    = [ \t\n\r]*
