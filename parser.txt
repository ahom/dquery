{
    function parse_repetition(name, expr_name, head, tail, op_idx, expr_idx) { 
        if (tail.length === 0) {
            return head;
        }
        let rv = null;
        tail.map(function (item) {
            if (rv !== null && item[op_idx].toUpperCase() === rv.op) {
                rv[expr_name].push(item[expr_idx]);
            } else {
                if (rv === null) {
                    rv = head;
                }
                let next_rv = {
                    type: name,
                    op: item[op_idx].toUpperCase()
                };
                next_rv[expr_name] = [rv, item[expr_idx]];
                rv = next_rv;
            }
        });
        return rv;
    }
    
    function parse_mapping(key, expr, tail, key_idx, expr_idx) {
        let rv = {};
        rv[key] = expr;
        tail.map(function (item) {
            rv[item[key_idx]] = item[expr_idx];
        });
        return rv;
    }
}

// QUERY
Query
  = sub:SubQuery 
  group_by:(_ GroupByStatement)? 
  having:(_ HavingStatement)? 
  order_by:(_ OrderByStatement)? 
  skip:(_ SkipStatement)? 
  limit:(_ LimitStatement)? {
      return {
          type: "query",
          sub: sub,
          group_by: group_by ? group_by[1] : undefined,
          having: having ? having[1] : undefined,
          order_by: order_by ? order_by[1] : undefined,
          skip: skip ? skip[1] : undefined,
          limit: limit ? limit[1] : undefined
      };
  }

SubQuery 
  = select:SelectStatement 
  _ from:FromStatement 
  unnest:(_ UnNestStatement)* 
  where:(_ WhereStatement)? 
  skip:(_ SkipStatement)? 
  limit:(_ LimitStatement)? {
      return {
          type: "sub_query",
          select: select,
          from: from,
          unnests: unnest.map(function (item) { return item[1]; }),
          where: where ? where[1] : undefined,
          skip: skip ? skip[1] : undefined,
          limit: limit ? limit[1] : undefined
      };
  }

ExpressionSubQuery
  = (sub:SubQuery
  op:(_ ("UNION"i / "INTERSECT"i / "EXCEPT"i) (_ "ALL"i)? _ ExpressionSubQuery)?) {
     if (op) {
         return {
             type: "expr_sub_query",
             lhq: sub,
             op: op[1].toUpperCase(),
             op_modifier: op[2] ? op[2][1].toUpperCase() : undefined,
             rhq: op[4]
         };
     } else {
         return sub;
     }
  }
  / "(" _ sub:ExpressionSubQuery _ ")" {
      return sub;
  }
  
// STATEMENTS
SelectStatement
  = "SELECT"i _ map:(SelectMapping / SimplifiedSelectMapping) {
      return {
          type: "select_stat",
          map: map
      };
  }

SimplifiedSelectMapping
  = expr:Expression alias:(_ "AS"i _ KeyName)? tail:(_ "," _ Expression (_ "AS"i _ KeyName)?)* {
     return {
         type: "simplified_select_mapping",
         map: [{
             expr: expr,
             alias: alias ? alias[3] : undefined
         }].concat(tail.map(function (item) {
             return {
                 expr: item[3],
                 alias: item[4] ? item[4][3] : undefined
             };
         }))
     };
  }

SelectMapping 
  = "{" _ key:KeyName _ ":" _ expr:(ExpressionSubQuery / Expression) tail:(_ "," _ KeyName _ ":" _ (ExpressionSubQuery / Expression))* _ "}" { 
        return {
        	type: "select_mapping",
        	map: parse_mapping(key, expr, tail, 3, 7)
        };
    }

FromStatement
  = "FROM"i _ arr:(Path / ExpressionSubQuery) alias:(_ "AS"i _ KeyName)? {
      return {
          type: "from_stat",
          alias: alias ? alias[3] : undefined,
          arr: arr
      };
  }

UnNestStatement
  = "UNNEST"i _ path:Path {
      return {
          type: "unnest_stat",
          path: path
      };
  }

WhereStatement
  = "WHERE"i _ cond:Condition {
      return {
          type: "where_stat",
          cond: cond
      };
  }

GroupByStatement
  = "GROUP"i _ "BY"i _ head:Expression tail:(_ "," _ Expression)* {
      return {
          type: "group_by_stat",
          exprs: [head].concat(tail.map(function (item) { return item[3]; }))
      };
  }

HavingStatement
  = "HAVING"i _ cond:Condition {
      return {
          type: "having_stat",
          cond: cond
      };
  }

OrderByStatement
  = "ORDER"i _ "BY"i _ head:(Expression (_ "ASC"i / "DESC"i)?) tail:(_ "," _ Expression (_ "ASC"i / "DESC"i)?)* {
      return {
          type: "order_by_stat",
          orders: [{
              expr: head[0],
              order: head[1] ? head[1][1].toUpperCase() : "ASC"
          }].concat(tail.map(function (item) {
              return {
                  expr: item[3],
                  order: item[4] ? item[4][1].toUpperCase() : "ASC"
              };
          }))
      };
  }

SkipStatement
  = "SKIP"i _ val:Integer {
      return {
          type: "skip_stat",
          value: val
      };
  }
  
LimitStatement
  = "LIMIT"i _ val:Integer {
      return {
          type: "limit_stat",
          value: val
      };
  }

// CONDITIONS
Condition
  = OrCondition

OrCondition
  = head:AndCondition tail:(_ "OR"i _ AndCondition)* { 
          return parse_repetition("nary_cond_cond", "conds", head, tail, 1, 3);
    }

AndCondition
  = head:BaseCondition tail:(_ "AND"i _ BaseCondition)* { 
          return parse_repetition("nary_cond_cond", "conds", head, tail, 1, 3);
    }

BaseCondition
  = IsNullCondition 
  / BinaryExprCondition 
  / EachCondCondition 
  / ListCondition 
  / LikeCondition 
  / NotCondition 
  / "(" _ cond:Condition _ ")" { 
          return cond;
    }

NotCondition
  = "NOT"i _ cond:BaseCondition { 
          return {
            type: "not_cond",
            cond: cond
        };
    }

EachCondCondition
  = op:("ANY"i / "ALL"i) _ path:Path _ "MATCH"i _ cond:BaseCondition { 
          return {
            type: "each_cond_cond",
            path: path,
            op: op.toUpperCase(),
            cond: cond
        };
    }

ListCondition
  = path:Path _ op:( "IN"i / "NIN"i ) _ "(" _ head:Value tail:(_ "," _ Value)* _ ")" { 
          return {
            type: "list_cond",
            path: path,
            op: op.toUpperCase(),
            values: [head].concat(tail.map(function(item) { return item[3]; }))
        };
    }

LikeCondition
  = path:Path _ "LIKE"i _ regex:String { 
        return {
            type: "like_cond",
            path: path,
            regex: regex
        };
    }
  
IsNullCondition
  = path:Path _ "IS"i _ "NULL"i { 
          return {
            type: "is_null_cond",
            path: path
        };
    }

BinaryExprCondition
  = lhe:Expression _ op:( "<=" / "<" / ">=" / ">" / "!=" / "=" ) _ rhe:Expression { 
          return {
            type: "binary_expr_cond",
            lhe: lhe,
            op: op,
            rhe: rhe
        };
    }

  
// EXPRESSIONS
Expression
  = ReducedExpression 
  / AddExpression

ReducedExpression
  = op:("SUM"i / "AVG"i / "COUNT"i / "MIN"i / "MAX"i) _ "(" _ expr:(ExpressionSubQuery / Expression) _ ")" {
      return {
          type: "reduced_expr",
          expr: expr
      };
  }

AddExpression
  = head:MulExpression tail:(_ ( "+" / "-" ) _ MulExpression)* { 
          return parse_repetition("nary_expr_expr", "exprs", head, tail, 1, 3);
    }
  
MulExpression
  = head:BaseExpression tail:(_ ( "*" / "/" ) _ BaseExpression)* { 
          return parse_repetition("nary_expr_expr", "exprs", head, tail, 1, 3);
    }
      
BaseExpression
  = Value 
  / Path 
  / "("_ expr:Expression _ ")" {
      return expr;
  }

Path
  = KeyName ("." KeyName)* { 
          return {
            type: "path",
            value: text() 
        }
    }

Value
  = String 
  / Boolean 
  / Number 
  / Date 
  / Timestamp

Timestamp
  = "TIMESTAMP"i _ "\"" year:(digit digit digit digit) "-" month:(digit digit) "-" day:(digit digit) " " hour:(digit digit) ":" minutes:(digit digit) ":" seconds:(digit digit) "\"" { 
        return {
            type: "timestamp",
            value: new Date(
                parseInt(year.join(""), 10), 
                parseInt(month.join(""), 10),
                parseInt(day.join(""), 10),
                parseInt(hour.join(""), 10),
                parseInt(minutes.join(""), 10),
                parseInt(seconds.join(""), 10)
            )
        };
    }

Date
  = "DATE"i _ "\"" year:(digit digit digit digit) "-" month:(digit digit) "-" day:(digit digit) "\"" { 
        return {
            type: "date",
            value: new Date(
                parseInt(year.join(""), 10), 
                parseInt(month.join(""), 10),
                parseInt(day.join(""), 10)
            )
        };
    }

digit
  = [0-9]

Boolean
  = ("TRUE"i / "FALSE"i) { 
        return {
            type: "value",
            value: text().toUpperCase() === "TRUE" 
        };
    }

String
  = "\"" val:[^"]* "\"" { 
          return {
            type: "string",
            value: val.join("")
        };
    }

Number
  = Integer 
  / Float

Float
  = ("-"/"+")?[0-9]+("."[0-9]+)? { 
          return {
            type: "float",
            value: parseFloat(text())
        };
    }

Integer
  = [0-9]+ { 
          return {
            type: "integer",
            value: parseInt(text(), 10)
        };
    }

KeyName
  = [a-zA-Z0-9_-]+ {
        return text();
  }
  
_ "whitespace"
  = [ \t\n\r]*
